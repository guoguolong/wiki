coroutine你可以将它看成一个用户态的线程（一般来它也提供了入口函数、调用的参数，以及你放置局部变量的栈），只不过它是你自己调度的，而且不同coroutine的切换不需要陷入内核态，效率比较高。

linux有提供了getcontext swapcontext等接口来实现coroutine，windows貌似也有相关的。一般来说coroutine用在异步的场景比较好，异步执行一般需要维护一个状态机，状态的维护需要保存在全局里或者你传进来的参数来，因为每一个状态回调都会重新被调用。有了coroutine(stackfull)的话你可以不用担心这个问题，你可以像写同步的代码那样子，但其实底层还是异步的，只不过你在等待数据时执行的上下文会暂时被保存起来，等到数据来临再将上下文恢复继续执行。还有一种coroutine是stackless，它本质上也是状态机实现的，并不能在它上面让不同的状态共享局部变量，貌似boost.asio.coroutine就是这种。