简要介绍编写C/C ++应用程序的领域，标准库的作用以及它是如何在各种操作系统中实现的。

我已经接触C++一段时间了，一开始就让我感到疑惑的是其内部结构：我所使用的内核函数和类从何而来？ 谁发明了它们？ 他们是打包在我系统中的某个地方吗？ 是否存在一份官方的C ++手册？

在本文中，我将通过从C和C ++语言的本质到实际实现来尝试回答这些问题。

## C和C++是如何制订的

当我们谈论C和C++ 时，实际上是指一组定义（程序）语言应该做些什么，如何表现，应该提供哪些功能的规则。C/C++ 的编译器为了处理C/C++编写的源代码必须跟随着这些规则，并生成二进制应用程序。听起来非常接近于HTML:浏览器遵循着一组指令，所以它们可以以明确的方式来渲染网页。

与HTML一样，C和C++ 的规则都是理论上的。国际标准化组织(ISO)的一大群人每年都会聚集几次来讨论和定义语言规则。没错，C和C++ 是标准化的东西。他们最终都会得到一本官方的叫标准的书，你可以从他们的网站中购买。随着语言的发展新的papers（指官方的叫标准的书）会被发布，每一次都定义一个新的标准。这就是为什么我们会有不同的C和C++ 版本的原因：C99, C11, C++ 03, C++ 11, C++ 14等等，数字与出版/发布年份相符。

这些标准都市非常详细和有技术新的文档：我不会把它们当作手册。通常会分为两部分：

1.C/C++的功能和特性；

2.C/C的API--开发人员可以用于他们的C/C程序的一个类、函数和宏的集合。它也被称为标准库。

例如，这里有个来自于C标准库第一部分的摘选，它定义了main函数的结构:

## C标准库

C标准库也称为ISO C库，是用于完成诸如输入/输出处理、字符串处理、内存管理、数学计算和许多其他操作系统服务等任务的宏、类型和函数的集合。它是在C标准中（例如C11标准）中定义的。其内容分布在不同的头文件中，比如上面我所提到的math.h。

## C++标准库

和C标准库的概念类似，但仅针对C 。C标准库是一组C模板类，它提供了通用的编程数据结构和函数，如链表、堆、数组、算法、迭代器和任何其他你可以想到的C组件。C 标准库也包含了C标准库，并在C标准中进行了定义（例如C++ 11标准）。

## 实现C/C++标准库

我们从这里开始讨论真正的代码了。从事于标准库实现的开发者阅读官方的ISO规范并将其转化为代码。他们必须依赖其操作系统所提供的功能（读/写文件，分配内存，创建线程，......所有这些被称为系统调用），因此每个平台都有其自己的标准库实现。 有时它是系统内核的一部分，有时它是作为一个附加组件 - 编译器 - 必须单独下载。

## GNU/Linux版实现

GNU C库，也称为glibc, 是C标准库的GNU项目实现。并非所有的标准C函数都可以在glibc中找到：大多数数学函数实际上是在libm库中实现的，这是一个独立的库。

截至今天，glibc是Linux上使用最广泛的C库。 然而，在90年代期间，有一段时间里，glibc有一个竞争对手称为Linux libc（或者简称libc），它是由glibc 1.x的一个分支产生的。在一段时间里，Linux libc是许多Linux发行版中的标准C库。

经过多年的发展，glibc竟然比Linux libc更具优势，并且所有使用它的Linux发行版都切换回了glibc。所以，如果你在你的磁盘中找到一个名为libc.so.6的文件，请不要担心：它是现代版的glibc。为了避免与之前的Linux libc版本混淆，版本号增加到了6（他们无法将其命名为glibc.so.6：所有Linux库都必须以lib前缀打头）。

另一方面，C标准库的实现位于libstdc或GNU标准C库中。这是一个正在进行的在GNU/Linux上实现标准C库的项目。一般来说，所有常规的Linux发行版都默认使用libstdc++。

## Mac和iOS版实现

在Mac和iOS上，C标准库的实现是libSystem的一部分，libSystem是位于/usr/lib/libSystem.dylib中的核心库。LibSystem包含其他组件，如数学库、线程库和其他底层实用程序。

关于 C++ 标准库，在OS X Mavericks（V10.9）之前的Mac上，libstdc是默认选项。这在现代的基于Linux的系统上可以找到的同样的实现。自OS X Mavericks开始，Apple切换到使用libc ，这是LLVM项目——Mac官方编译器框架——所引入的GNU libstdc++标准库的替代。

IOS开发者可以使用iOS SDK（软件开发工具包）来访问标准库，它是一系列允许创建移动应用程序的工具。

## Windows版实现

在Windows上，标准库的实现一直严格限定在Visual Studio中，它是微软官方的编译器。他们通常称之为 C/C++ 运行时库（CRT），并且它涵盖了 c/c++ 二者的实现。

在最开始，CRT被实现为CRTDLL.DLL库（我猜，当时没有可用的 C++ 标准库）。从Windows 95开始，Microsoft开始将其迁移到MSVCRT [版本号] .DLL（MSVCR20.DLL，MSVCR70.DLL等）之上，据推测也包含 C++ 标准库。在1997年左近，他们决定将文件名简化为MSVCRT.DLL，这不幸导致了令人讨厌的DLL混乱。这就是为什么从Visual Studio 7.0版开始，他们切换回每个版本使用单独的DLL了。

Visual Studio 2015引入了深度的CRT重构。 C/C++ 标准库的实现迁移到一个新库，Universal C运行时库 (Universal CRT或UCRT)，编译为UCRTBASE.DLL。 UCRT目前已经成为Windows组之一，从Windows 10开始作为操作系统的一部分提供。

## Android版实现

Bionic是Google为其Android操作系统所编写的C标准库实现，它直接在底层使用。 第三方开发者可以通过Android原生开发工具包（NDK）访问Bionic，该工具集允许你使用C和C++代码编写Android应用程序。

在 C++ 端, NDK提供了很多版本的实现：

- libc++，从从Lollipop开始的官方安卓系统和现代Mac操作系统都将其作为 C++ 标准库使用。从NDK发布17版本开始，它将成为NDK中唯一可用的 C++ 标准库实现；
- gnustl，libstdc++的别名，这两者在GNU/linux是同一个库。这个库的已被弃用，它将在NDK发布18中删除；
- STLport，由STLport项目编写的C++标准库的第三方实现，自2008年以来一直处于不活跃状态。与gnustl一样，STLport将在NDK发布18中移除。

## 我能使用不同版本的实现代码来替代默认实现吗？

如果你正在使用资源非常有限的系统，则通常需要引用C标准库的不同实现。比如，uClibc-ng, musl libc和diet libc等等，所有这些都适用于嵌入式Linux系统的开发，提供更小的二进制文件和更少的内存占用。

C++ 标准库也有不同的实现版本：Apache C++ 标准库，uSTL以及EASTL等等。后面两个实际上仅关注模板部分，而不是完整的库，并且他们是在速度优先的情况下开发的。Apache版本的库注重的是可移植性。

## 如果我们脱离了标准库怎么办？

不使用标准库很简单：只要在你的程序中不引入它们的任何一个头文件，你的工作就完成了。然而，为了让这个操作更有意义一些，你需要通过一些提供的系统调用使用某种方法与操作系统互动。就像我之前说的，这就是标准库中的函数/方法在底层实现的时候所使用的。很可能你也会不得不调用这些方法来与硬件设备交互。

如果对你来说这听起来很让人激动，有些人已经开始在网上尝试在不导入标准库的情况下创建工作流程。因为你依赖于一个特定操作系统所提供的函数，这种方式会丧失可移植性。然而通过使用这种艰难的方式，肯会让你学到更多，而且让你更好的理解当你所做的事情，即使是在使用高级库的时候。

除了知识，当你在嵌入式操作系统上面工作的时候你不会想去引入标准库：因为代码不需要移植，在有限的内存中每个字节都很重要，这会让你更加精准的写代码。另一个使用背景就是demoscene，在这里人们尽量有限的程序的二进制大小中去保留高质量的音视频——4K仍然不是最小值：一些demoparties使用1K，256字节，64字节或者甚至32字节来竞争。在那里不允许使用标准库！