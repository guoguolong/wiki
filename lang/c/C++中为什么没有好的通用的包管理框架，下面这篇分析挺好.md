先说结论：c/c和其他语言不同，要管理c/c的包，你需要管理的不是"as is"，而是"source"。写程序的人需要的包管理器，和管理系统的人需要的包管理器是不一样的。

npm/apt/yum之类的包管理器的特点主要是"as is"，也就是下载下来就可以用。这样子对于C++来说是非常非常难以做到的，比如：

1. Windows下的MT/MTd/MD/MDd我无法解决。换言之，如果要通用，Windows 32bit就要至少提供四套binary。更加烦的是从Visual Studio 2012开始还需要指定XP兼容性。此外Debug Info指向的cpp文件是绝对路径，也就是换个电脑你只能手动指定源文件的位置。
2. Linux下的binary也有区别，举个例子，有RTTI和没有RTTI的代码是没法链接在一起的。

如果我需要要做到"as is"，我不单单需要为不同的系统、配置提供不同的binary，还需要为一些编译选项提供不同的binary。于是一个版本，我将提供几乎数不清的binary，因为不同的配置、系统、编译选项之间还可以做笛卡尔积。更何况，只有binary并不能调试，Debug Info通常占用的空间会比binary更加巨大，常常可以做到几个G，单单是压缩这些Debug Info就会耗费几十分钟的时间，对于包发布者来说，是个巨大的压力。

此外，C由于其复杂的历史原因，造成了复杂的依赖项，有的依赖perl，有的依赖于python，。这些项目的历史悠久，有无数数不清的坑。想要做到"Modern"，不是不想，而是实在是做不到。比如LLVM和Clang，已经算是这些项目中非常优秀的项目了，历史包袱也不是非常多，代码非常优秀，模块化，可是做了不知道多久还没有彻底从Autotools迁移到CMake。这些复杂的依赖项是没有办法说直接"as is"使用的，因为他们的目录的位置并不是遵循一个统一的标准，如果说有一个统一的标准，那么C的包管理器会好做很多。

同样的问题，出现在同样历史悠久的PHP身上。PHP本身有非常多的坑，这个就不细说了，而Composer花费了近10年时间才逐渐将PHP变成了现在这个Modern的样子（当然还有PHP自己的努力）。

有C包管理器尝试说要求每个添加进库的项目都必须是符合规定的，例如，比如使用CMake。很不幸，目前C领域最多人用的包管理器是这个思路。CMake非常优秀，然而正如我上面所说。但逐一纠正每个包，几乎是不可能的。我认为更实际的做法是，为每个包写一个编译配置，只需要编译好的头文件和二进制符合规范即可。我们必须要兼顾到C/C++悠久的历史所导致的无数的编译环境，例如autotools, CMake, gyp, ninjia。

最近很火的Rust的包管理器Cargo，所使用的方法，如我所使用的一样，是将源代码包"as is"下载下来，在编译的时候，优先编译dependencies。我认为这是比较符合实际的做法，它避免了我所上面列举的一些问题：

1. Binary的规则太细并不互相兼容：重新编译可以保证编译选项是兼容的。
2. 所依赖的包太多历史包袱，无法兼容新的标准：即时编译以后将编译好的二进制和文件按照统一的规范存储到新的位置。

Rust的Cargo的一个问题是要求必须使用Rust的脚本编译，而不是Shell。这样子对于我们来说也许是坏消息。但对于Rust来说，可以避免其仓库被海量的C++代码库湮灭，也许是幸运。

就算是如我上面所说，还会有一些新的问题：

1. 编译的时间太久：于是可以使用缓存的方法，将一个依赖项的某一个配置缓存起来。这对于其他语言来说可能不是刚需，但对于C++来说，简直太需要了。
2. 为每个包写符合规范的配置选项，仍然会是一个很大的工作量。这一点我相信靠我们的努力，未来会做得更好。